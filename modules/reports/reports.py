import os
import json
import datetime
import uuid
import traceback
import random  # Dodane dla funkcji _generate_test_performance_data
from functools import wraps
import pandas as pd
from flask import session, abort, render_template_string

# Add missing imports for PDF generation with improved error handling
PDF_BACKEND = None
WEASYPRINT_AVAILABLE = False
PDFKIT_AVAILABLE = False  # Define PDFKIT_AVAILABLE at the top level

try:
    from weasyprint import HTML, CSS
    WEASYPRINT_AVAILABLE = True
    PDF_BACKEND = 'weasyprint'
    print("Using WeasyPrint for PDF generation")
except ImportError:
    WEASYPRINT_AVAILABLE = False
    try:
        import pdfkit
        PDFKIT_AVAILABLE = True
        PDF_BACKEND = 'pdfkit'
        print("Using PDFKit for PDF generation")
    except ImportError:
        PDFKIT_AVAILABLE = False
        print("No PDF generation backend available")

from ..core.database import get_db_cursor

# Directory for storing generated reports
REPORTS_DIR = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'reports')
# Create reports directory if it doesn't exist
os.makedirs(REPORTS_DIR, exist_ok=True)

# Display PDF generation capability
print(f"PDF Generation Capability: WeasyPrint={WEASYPRINT_AVAILABLE}, PDFKit={PDFKIT_AVAILABLE}")

def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not session.get('logged_in'):
            abort(401)
        return f(*args, **kwargs)
    return decorated_function

class ReportGenerator:
    """Class for generating various types of reports."""
    
    def __init__(self, report_type, output_format, date_range, fields=None, 
                 start_date=None, end_date=None, record_limit=500, preview=False, language='en'):
        """Initialize report generator with parameters."""
        self.report_type = report_type
        self.output_format = output_format
        self.date_range = date_range
        self.fields = fields or []
        self.start_date = start_date
        self.end_date = end_date
        self.record_limit = int(record_limit) if record_limit != 'all' else None
        self.preview = preview
        self.language = language  # Add language parameter
        self._process_date_range()
        
        # Debug information
        print(f"ReportGenerator initialized:")
        print(f" - Type: {report_type}")
        print(f" - Format: {output_format}")
        print(f" - Date Range: {date_range}")
        print(f" - Start Date: {start_date}")
        print(f" - End Date: {end_date}")
        print(f" - Fields: {fields}")
        print(f" - Record Limit: {record_limit}")
        print(f" - Language: {language}")
        
    # Translation dictionaries for report templates
    TRANSLATIONS = {
        'en': {
            'report_types': {
                'messages': 'Messages Report',
                'errors': 'Errors Report',
                'performance': 'Performance Report',
                'summary': 'Summary Report'
            },
            'metadata_labels': {
                'report_type': 'Report Type',
                'date_range': 'Date Range',
                'generated_on': 'Generated On',
                'total_records': 'Total Records'
            },
            'footer': 'Generated by Monitoring System on',
            'sections': {
                'system_overview': 'System Overview',
                'host_status': 'Host Status',
                'system_logs': 'System Logs',
                'assets': 'Assets'
            },
            'metrics': {
                'monitored_hosts': 'Monitored Hosts',
                'hosts': 'Hosts',
                'logs': 'Logs',
                'devices': 'Devices',
                'no_data': 'No Data',
                'no_records': 'No records found for the selected period'
            },
            'columns': {
                # Messages report
                'timestamp': 'Timestamp',
                'level': 'Level',
                'severity': 'Severity',
                'category': 'Category',
                'message': 'Message',
                'details': 'Details',
                # Errors report
                'log_id': 'Log ID',
                'source': 'Source',
                'host_name': 'Host Name',
                # Performance report
                'metric_id': 'Metric ID',
                'host_id': 'Host ID',
                'metric_type': 'Metric Type',
                'value': 'Value',
                # Summary report
                'category': 'Category',
                'metric': 'Metric',
                'period': 'Period'
            }
        },
        'pl': {
            'report_types': {
                'messages': 'Raport wiadomości',
                'errors': 'Raport błędów',
                'performance': 'Raport wydajności',
                'summary': 'Raport podsumowujący'
            },
            'metadata_labels': {
                'report_type': 'Typ raportu',
                'date_range': 'Zakres dat',
                'generated_on': 'Wygenerowano',
                'total_records': 'Liczba rekordów'
            },
            'footer': 'Wygenerowane przez System Monitoringu',
            'sections': {
                'system_overview': 'Przegląd systemu',
                'host_status': 'Status hostów',
                'system_logs': 'Logi systemowe',
                'assets': 'Zasoby'
            },
            'metrics': {
                'monitored_hosts': 'Monitorowane hosty',
                'hosts': 'Hosty',
                'logs': 'Logi',
                'devices': 'Urządzenia',
                'no_data': 'Brak danych',
                'no_records': 'Nie znaleziono rekordów dla wybranego okresu'
            },            'columns': {
                # Messages report
                'timestamp': 'Data i czas',
                'level': 'Poziom',
                'severity': 'Ważność',
                'category': 'Kategoria',
                'message': 'Wiadomość',
                'details': 'Szczegóły',
                # Errors report
                'log_id': 'ID logu',
                'source': 'Źródło',
                'host_name': 'Nazwa hosta',
                # Performance report
                'metric_id': 'ID metryki',
                'host_id': 'ID hosta',
                'metric_type': 'Typ metryki',
                'value': 'Wartość',
                # Summary report
                'category': 'Kategoria',
                'metric': 'Metryka',
                'period': 'Okres'
            },            'data_values': {
                # Level translations
                'INFO': 'INFORMACJA',
                'WARN': 'OSTRZEŻENIE',
                'WARNING': 'OSTRZEŻENIE',
                'ERROR': 'BŁĄD',
                'DEBUG': 'DEBUGOWANIE',
                'FATAL': 'KRYTYCZNY',
                # Severity translations
                'low': 'niski',
                'medium': 'średni',
                'high': 'wysoki',
                'critical': 'krytyczny',
                # Category translations
                'General Warning': 'Ogólne ostrzeżenie',
                'System Error': 'Błąd systemu',
                'Service Status': 'Status usługi',
                'Performance Issue': 'Problem wydajności',
                'Security Alert': 'Alert bezpieczeństwa',
                'Network Issue': 'Problem sieciowy',
                'Database Error': 'Błąd bazy danych',
                'Application Error': 'Błąd aplikacji',
                # Performance metrics translations
                'cpu_usage': 'użycie CPU',
                'memory_usage': 'użycie pamięci',
                'disk_usage': 'użycie dysku',
                'network_io': 'I/O sieci',
                'disk_io': 'I/O dysku',
                # Server names translations
                'server1': 'serwer1',
                'server2': 'serwer2',
                'webserver': 'serwer www',
                'database': 'baza danych',
                'mailserver': 'serwer poczty',                # Error report source translations
                'graylog': 'graylog',
                'system': 'system',
                'application': 'aplikacja',
                'database': 'baza danych',
                # Summary report category translations
                'messages': 'wiadomości',
                'hosts': 'hosty',
                'errors': 'błędy',
                'performance': 'wydajność',
                # Summary report metric translations
                'online': 'online',
                'offline': 'offline',
                'maintenance': 'konserwacja',
                'total': 'razem'
            }
        }
    }

    def _process_date_range(self):
        """Process date range selection into start and end dates."""
        today = datetime.datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)
          # Only process if custom dates aren't already provided
        if self.date_range != 'custom' or not (self.start_date and self.end_date):
            if self.date_range == 'today':
                self.start_date = today
                self.end_date = today.replace(hour=23, minute=59, second=59)
            elif self.date_range == 'week':
                # Last 7 days
                self.start_date = today - datetime.timedelta(days=7)
                self.end_date = today.replace(hour=23, minute=59, second=59)
            elif self.date_range == 'month':
                # Last 30 days
                self.start_date = today - datetime.timedelta(days=30)
                self.end_date = today.replace(hour=23, minute=59, second=59)
            elif self.date_range == 'custom':
                # Custom range is handled by the form inputs
                pass
            else:                # Default to last 7 days
                self.start_date = today - datetime.timedelta(days=7)
                self.end_date = today.replace(hour=23, minute=59, second=59)
        
        print(f"Date range processed: {self.start_date} to {self.end_date}")

    def _format_date_range(self):
        """Format date range with proper translation for 'to' word."""
        start_str = self.start_date.strftime('%Y-%m-%d')
        end_str = self.end_date.strftime('%Y-%m-%d')
        
        if self.language == 'pl':
            return f"{start_str} do {end_str}"
        else:
            return f"{start_str} to {end_str}"

    def _translate_dataframe_columns(self, df):
        """Translate DataFrame column names based on selected language."""
        lang = self.language if self.language in self.TRANSLATIONS else 'en'
        translations = self.TRANSLATIONS[lang]['columns']
        
        # Create a mapping of original column names to translated ones
        translated_columns = {}
        for col in df.columns:
            col_lower = col.lower()  # For case-insensitive matching
            # If a translation exists for this column, use it; otherwise keep original
            if col_lower in translations:
                translated_columns[col] = translations[col_lower]
            else:
                translated_columns[col] = col
                  # Rename the DataFrame columns
        return df.rename(columns=translated_columns)
        
    def _translate_dataframe_values(self, df):
        """Translate DataFrame data values based on selected language."""
        if self.language != 'pl':
            return df  # Only translate for Polish language
            
        print(f"DEBUG: Translating data values for language: {self.language}")
        print(f"DEBUG: DataFrame columns: {list(df.columns)}")
        
        # Make a copy to avoid modifying the original
        translated_df = df.copy()
        
        # Get the data value translations for Polish
        data_translations = self.TRANSLATIONS['pl'].get('data_values', {})
        print(f"DEBUG: Available translations: {list(data_translations.keys())}")
        
        # Define column mapping for translation - exact column names to check
        columns_to_translate = {
            'level': True,          # Messages/errors level
            'Level': True,
            'poziom': True,
            'Poziom': True,
            'severity': True,       # Messages/errors severity
            'Severity': True, 
            'ważność': True,
            'Ważność': True,
            'category': True,       # Messages/errors category
            'Category': True,
            'kategoria': True,
            'Kategoria': True,
            'metric_type': True,    # Performance report metric types
            'Metric Type': True,
            'typ metryki': True,
            'Typ metryki': True,
            'Typ Metryki': True,
            'source': True,         # Error report sources
            'Source': True,
            'źródło': True,
            'Źródło': True,            'host_name': True,      # Host names in various reports
            'Host Name': True,
            'nazwa hosta': True,
            'Nazwa hosta': True,
            'Nazwa Hosta': True,
            'metric': True,         # Summary report metrics
            'Metric': True,
            'metryka': True,
            'Metryka': True
        }
        
        for col in translated_df.columns:
            # Check if this exact column name should be translated
            should_translate = columns_to_translate.get(col, False)
            print(f"DEBUG: Column '{col}' should translate: {should_translate}")
            
            if should_translate:
                print(f"DEBUG: Translating column '{col}'")
                original_values = translated_df[col].unique()[:5]  # First 5 unique values
                print(f"DEBUG: Original values sample: {original_values}")
                
                # Translate values in this column
                translated_df[col] = translated_df[col].apply(
                    lambda x: data_translations.get(str(x), str(x)) if pd.notna(x) else x
                )
                
                translated_values = translated_df[col].unique()[:5]  # First 5 unique values
                print(f"DEBUG: Translated values sample: {translated_values}")
        
        return translated_df
    
    def _resize_table_for_pdf(self, df):
        """Resize table content to fit better in PDF documents."""
        # Make a copy to avoid modifying the original
        resized_df = df.copy()
        
        # For string columns that might be too long
        for col in resized_df.select_dtypes(include=['object']).columns:
            # Get max length in this column
            max_length = resized_df[col].astype(str).str.len().max()
            
            # If any values are too long, truncate them
            if max_length > 50:  # Threshold for "too long"
                resized_df[col] = resized_df[col].astype(str).apply(
                    lambda x: (x[:47] + '...') if len(x) > 50 else x
                )
        
        return resized_df

    def get_data(self):
        """Fetch data for the report based on report_type."""
        try:
            print(f"Getting data for report type: {self.report_type}")
            method_name = f'_get_{self.report_type}_data'
            
            if hasattr(self, method_name):
                data = getattr(self, method_name)()
                print(f"Retrieved {len(data)} records")
                return data
            else:
                print(f"No method found for report type: {self.report_type}")
                return []
        except Exception as e:
            print(f"Error getting data: {str(e)}")
            traceback.print_exc()
            return []

    def _get_messages_data(self):
        """Get log messages data from graylog_messages table."""
        with get_db_cursor() as cursor:
            try:
                sql = """
                    SELECT 
                        timestamp, 
                        level, 
                        severity, 
                        category, 
                        message, 
                        details
                    FROM graylog_messages
                    WHERE timestamp BETWEEN %s AND %s
                """
                
                params = [self.start_date, self.end_date]
                
                # Add limit if specified
                if self.record_limit:
                    sql += " LIMIT %s"
                    params.append(self.record_limit)
                
                cursor.execute(sql, params)
                results = cursor.fetchall()
                print(f"Retrieved {len(results)} message records")
                return results
            except Exception as e:
                print(f"Error getting messages data: {str(e)}")
                traceback.print_exc()
                return []
    
    def _get_errors_data(self):
        """Get error log data from system_errors table."""
        with get_db_cursor() as cursor:
            try:
                sql = """
                    SELECT 
                        log_id,
                        timestamp, 
                        level, 
                        source,
                        host_name,
                        message, 
                        details
                    FROM system_errors
                    WHERE timestamp BETWEEN %s AND %s
                    AND level IN ('error', 'critical', 'fatal')
                """
                
                params = [self.start_date, self.end_date]
                
                # Add limit if specified
                if self.record_limit:
                    sql += " LIMIT %s"
                    params.append(self.record_limit)
                
                cursor.execute(sql, params)
                results = cursor.fetchall()
                print(f"Retrieved {len(results)} error records")
                return results
            except Exception as e:
                print(f"Error getting errors data: {str(e)}")
                traceback.print_exc()
                  # Try fallback query if the error is about missing table
                if "Table" in str(e) and "doesn't exist" in str(e):
                    print("Attempting fallback query to graylog_messages for errors")
                    return self._get_errors_fallback_data()
                return []
    def _get_errors_fallback_data(self):
        """Fallback method to get error data from graylog_messages if system_errors doesn't exist."""
        with get_db_cursor() as cursor:
            try:
                sql = """
                    SELECT 
                        id as log_id,
                        timestamp, 
                        level, 
                        category as source,
                        COALESCE(JSON_UNQUOTE(JSON_EXTRACT(details, '$.formsdbsessionid')), 'unknown') as host_name,
                        message, 
                        details
                    FROM graylog_messages
                    WHERE timestamp BETWEEN %s AND %s
                    AND level IN ('error', 'critical', 'fatal')
                """
                
                params = [self.start_date, self.end_date]
                
                # Add limit if specified
                if self.record_limit:
                    sql += " LIMIT %s"
                    params.append(self.record_limit)
                
                cursor.execute(sql, params)
                results = cursor.fetchall()
                print(f"Retrieved {len(results)} error records from fallback")
                return results
            except Exception as e:
                print(f"Error in fallback query: {str(e)}")
                traceback.print_exc()
                return []
    
    def _get_performance_data(self):
        """Get performance metrics data."""
        with get_db_cursor() as cursor:
            try:
                # Try to get from dedicated performance metrics table first
                sql = """
                    SELECT 
                        m.metric_id,
                        m.timestamp, 
                        m.host_id,
                        h.hostname as host_name,
                        m.metric_type,
                        m.value
                    FROM performance_metrics m
                    LEFT JOIN hosts h ON m.host_id = h.id
                    WHERE m.timestamp BETWEEN %s AND %s
                """
                
                params = [self.start_date, self.end_date]
                
                # Add limit if specified
                if self.record_limit:
                    sql += " LIMIT %s"
                    params.append(self.record_limit)
                
                try:
                    cursor.execute(sql, params)
                    results = cursor.fetchall()
                    if results:
                        print(f"Retrieved {len(results)} performance metrics")
                        return results
                except Exception as e:
                    print(f"Error in primary performance query: {str(e)}")
                    # Continue to fallback if this fails
                
                # Fallback to generic metrics table if the specific one doesn't exist
                sql = """
                    SELECT 
                        id as metric_id,
                        timestamp, 
                        host_id,
                        '' as host_name,
                        metric_name as metric_type,
                        metric_value as value
                    FROM system_metrics
                    WHERE timestamp BETWEEN %s AND %s
                """
                
                params = [self.start_date, self.end_date]
                
                # Add limit if specified
                if self.record_limit:
                    sql += " LIMIT %s"
                    params.append(self.record_limit)
                
                cursor.execute(sql, params)
                results = cursor.fetchall()
                print(f"Retrieved {len(results)} performance metrics from fallback")
                return results
                
            except Exception as e:
                print(f"Error getting performance data: {str(e)}")
                traceback.print_exc()
                
                # If all queries fail, generate synthetic test data
                print("Generating synthetic performance data for testing")
                return self._generate_test_performance_data()
    
    def _generate_test_performance_data(self):
        """Generate synthetic performance data for testing."""
        test_data = []
        hosts = ['server1', 'server2', 'webserver', 'database']
        metrics = ['cpu_usage', 'memory_usage', 'disk_usage', 'network_io']
        
        # Generate data points from start_date to end_date
        current = self.start_date
        while current <= self.end_date:
            for host in hosts:
                for metric in metrics:
                    # Generate random value based on metric type
                    if metric == 'cpu_usage':
                        value = round(random.uniform(5, 95), 2)
                    elif metric == 'memory_usage':
                        value = round(random.uniform(20, 85), 2)
                    elif metric == 'disk_usage':
                        value = round(random.uniform(30, 90), 2)
                    else:  # network_io
                        value = round(random.uniform(100, 9500), 2)
                        
                    test_data.append({
                        'metric_id': f"test_{len(test_data) + 1}",
                        'timestamp': current,
                        'host_id': hosts.index(host) + 1,
                        'host_name': host,
                        'metric_type': metric,
                        'value': value
                    })
            
            # Move to next hour
            current += datetime.timedelta(hours=1)
            
            # Limit size of test data
            if len(test_data) >= 500:
                break
                
        return test_data
    
    def _get_summary_data(self):
        """Get summary report data combining various metrics."""
        try:
            # Get statistics from different sources
            message_stats = self._get_message_stats()
            host_stats = self._get_host_stats()
            error_stats = self._get_error_stats()
            
            # Combine all statistics into a single dataset
            summary_data = []
              # Add message statistics
            for category, count in message_stats.items():
                summary_data.append({
                    'category': 'messages',
                    'metric': category,
                    'value': count,
                    'period': self._format_date_range()
                })
            
            # Add host statistics
            for status, count in host_stats.items():
                summary_data.append({
                    'category': 'hosts',
                    'metric': status,
                    'value': count,
                    'period': self._format_date_range()
                })
            
            # Add error statistics
            for level, count in error_stats.items():
                summary_data.append({
                    'category': 'errors',
                    'metric': level,
                    'value': count,
                    'period': self._format_date_range()
                })
            
            return summary_data
        except Exception as e:
            print(f"Error getting summary data: {str(e)}")
            traceback.print_exc()
            return []
    
    def _get_message_stats(self):
        """Get message statistics by category."""
        with get_db_cursor() as cursor:
            try:
                cursor.execute("""
                    SELECT 
                        COALESCE(category, 'uncategorized') as category,
                        COUNT(*) as count
                    FROM graylog_messages
                    WHERE timestamp BETWEEN %s AND %s
                    GROUP BY category
                """, [self.start_date, self.end_date])
                
                results = cursor.fetchall()
                stats = {row['category']: row['count'] for row in results} if results else {}
                
                # Add total count
                stats['total'] = sum(stats.values())
                
                return stats
            except Exception as e:
                print(f"Error getting message stats: {str(e)}")
                return {'total': 0, 'error': 0, 'info': 0, 'warning': 0}
    
    def _get_host_stats(self):
        """Get host statistics by status."""
        with get_db_cursor() as cursor:
            try:
                cursor.execute("""
                    SELECT 
                        status,
                        COUNT(*) as count
                    FROM hosts
                    GROUP BY status
                """)
                
                results = cursor.fetchall()
                stats = {row['status']: row['count'] for row in results} if results else {}
                
                # Add total count
                stats['total'] = sum(stats.values())
                
                return stats
            except Exception as e:
                print(f"Error getting host stats: {str(e)}")
                # Generate dummy data for testing
                return {'online': 15, 'offline': 3, 'maintenance': 2, 'total': 20}
    
    def _get_error_stats(self):
        """Get error statistics by level."""
        with get_db_cursor() as cursor:
            try:
                # First try dedicated error table
                try:
                    cursor.execute("""
                        SELECT 
                            level,
                            COUNT(*) as count
                        FROM system_errors
                        WHERE timestamp BETWEEN %s AND %s
                        GROUP BY level
                    """, [self.start_date, self.end_date])
                    
                    results = cursor.fetchall()
                    if results:
                        stats = {row['level']: row['count'] for row in results}
                        stats['total'] = sum(stats.values())
                        return stats
                except Exception:
                    # Table might not exist, continue to fallback
                    pass
                    
                # Fallback to graylog_messages table
                cursor.execute("""
                    SELECT 
                        level,
                        COUNT(*) as count
                    FROM graylog_messages
                    WHERE timestamp BETWEEN %s AND %s
                    AND level IN ('error', 'critical', 'fatal', 'warning')
                    GROUP BY level
                """, [self.start_date, self.end_date])
                
                results = cursor.fetchall()
                stats = {row['level']: row['count'] for row in results} if results else {}
                
                # Add total count
                stats['total'] = sum(stats.values())
                
                return stats
            except Exception as e:
                print(f"Error getting error stats: {str(e)}")
                # Generate dummy data for testing
                return {'error': 12, 'critical': 3, 'fatal': 1, 'warning': 25, 'total': 41}

    def generate_report(self):
        """Generate the full report in the specified format."""
        try:
            # Get data for the report
            data = self.get_data()
            
            if not data:
                print("No data returned from get_data()")
                return {
                    'success': False,
                    'error': 'No data available for the report'
                }
            
            # Filter fields if needed
            if self.fields:
                data = self.filter_fields(data)
            
            # If this is just a preview request, return HTML preview
            if self.preview:
                preview_html = self.generate_html_preview(data)
                return {
                    'success': True,
                    'preview_html': preview_html
                }
            
            # Generate report based on the specified format
            if self.output_format == 'excel':
                return self._generate_excel(data)
            elif self.output_format == 'html':
                return self._generate_html(data)
            elif self.output_format == 'csv':
                return self._generate_csv(data)
            elif self.output_format == 'pdf':
                return self._generate_pdf(data)
            else:
                return {
                    'success': False,
                    'error': 'Unsupported output format'
                }
        except Exception as e:
            print(f"Error in generate_report: {str(e)}")
            traceback.print_exc()
            return {'success': False, 'error': f'Report generation failed: {str(e)}'}
            
    def filter_fields(self, data):
        """Filter data to include only selected fields."""
        if not self.fields or not data:
            return data
        
        filtered_data = []
        for item in data:
            filtered_item = {}
            for field in self.fields:
                if field in item:
                    filtered_item[field] = item[field]
            filtered_data.append(filtered_item)
        return filtered_data
    
    def generate_html_preview(self, data):
        """Generate HTML preview of the report."""
        if not data:
            return "<p>No data available for the selected criteria.</p>"
        
        try:
            # Use language-specific translations
            lang = self.language if self.language in self.TRANSLATIONS else 'en'
            translations = self.TRANSLATIONS[lang]
              # Convert to pandas DataFrame for easy HTML table generation
            df = pd.DataFrame(data)
            
            # Translate column headers and data values for the preview
            df = self._translate_dataframe_columns(df)
            df = self._translate_dataframe_values(df)  # Translate data values (for Polish)
            
            # Limit preview to a small number of records
            preview_count = min(10, len(df))
            preview_df = df.head(preview_count)
            
            # Generate nice HTML table
            table_html = preview_df.to_html(classes="preview-table", index=False)
            
            # Get report type from translations
            report_type_display = translations['report_types'].get(
                self.report_type, 
                self.report_type.capitalize()
            )
            
            preview_html = f"""
            <div class="preview-stats">
                <div class="preview-stat">
                    <span class="stat-label">{translations['metadata_labels']['total_records']}:</span>
                    <span class="stat-value">{len(df)}</span>
                </div>
                <div class="preview-stat">
                    <span class="stat-label">{translations['metadata_labels']['report_type']}:</span>
                    <span class="stat-value">{report_type_display}</span>
                </div>                <div class="preview-stat">
                    <span class="stat-label">{translations['metadata_labels']['date_range']}:</span>
                    <span class="stat-value">{self._format_date_range()}</span>
                </div>
            </div>
            <div class="preview-table-container">
                {table_html}
            </div>
            <style>
                .preview-stats {{
                    display: grid;
                    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
                    gap: 10px;
                    margin-bottom: 15px;
                }}
                .preview-stat {{
                    background-color: #f5f5f5;
                    padding: 8px 12px;
                    border-radius: 6px;
                }}
                .stat-label {{
                    display: block;
                    font-size: 0.8rem;
                    color: #666;
                }}
                .stat-value {{
                    font-weight: 500;
                    color: #333;
                }}
                .preview-table-container {{
                    max-height: 250px;
                    overflow-y: auto;
                    margin-bottom: 15px;
                }}
                .preview-table {{
                    width: 100%;
                    border-collapse: collapse;
                    font-size: 0.9rem;
                }}
                .preview-table thead {{
                    position: sticky;
                    top: 0;
                    background-color: #f0f0f0;
                    z-index: 10;
                }}
                .preview-table th, 
                .preview-table td {{
                    padding: 8px;
                    border: 1px solid #ddd;
                    text-align: left;
                }}
            </style>
            """
            return preview_html
        except Exception as e:
            print(f"Error generating HTML preview: {str(e)}")
            traceback.print_exc()
            return f"<p>Error generating preview: {str(e)}</p>"

    def _generate_html(self, data):
        """Generate HTML report with improved table formatting."""
        if not data:
            return {'success': False, 'error': 'No data available for the report'}
        
        try:
            # Use the language-specific translations
            lang = self.language if self.language in self.TRANSLATIONS else 'en'
            translations = self.TRANSLATIONS[lang]
              # Convert data to DataFrame
            df = pd.DataFrame(data)
            
            # Translate columns and resize data for better display
            df = self._translate_dataframe_columns(df)
            df = self._translate_dataframe_values(df)  # Translate data values (for Polish)
            df = self._resize_table_for_pdf(df)  # Works for HTML too
            
            # Generate filename
            timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"{self.report_type}_report_{timestamp}.html"
            filepath = os.path.join(REPORTS_DIR, filename)
            
            # Create HTML template
            html_template = """
            <!DOCTYPE html>
            <html lang="{{ language }}">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>{{ report_title }}</title>
                <style>
                    body {
                        font-family: Arial, sans-serif;
                        line-height: 1.6;
                        margin: 20px;
                        color: #333;
                    }
                    h1 {
                        color: #2c3e50;
                        border-bottom: 2px solid #3498db;
                        padding-bottom: 10px;
                        margin-bottom: 20px;
                    }
                    .report-header {
                        background-color: #f8f9fa;
                        padding: 15px;
                        border-radius: 5px;
                        margin-bottom: 20px;
                    }
                    .report-metadata {
                        display: flex;
                        flex-wrap: wrap;
                        gap: 20px;
                        margin-bottom: 15px;
                    }
                    .metadata-item {
                        flex: 1 0 200px;
                    }
                    .metadata-item h3 {
                        margin: 0 0 5px 0;
                        font-size: 14px;
                        color: #666;
                    }
                    .metadata-item p {
                        margin: 0;
                        font-weight: bold;
                        color: #333;
                    }
                    table.data-table {
                        width: 100%;
                        border-collapse: collapse;
                        margin: 20px 0;
                        font-size: 14px;
                    }
                    .data-table th, 
                    .data-table td {
                        padding: 10px;
                        border: 1px solid #ddd;
                        text-align: left;
                    }
                    .data-table th {
                        background-color: #f2f2f2;
                        color: #333;
                        font-weight: bold;
                        position: sticky;
                        top: 0;
                    }
                    .data-table tr:nth-child(even) {
                        background-color: #f9f9f9;
                    }
                    .data-table tr:hover {
                        background-color: #f1f1f1;
                    }
                    .footer {
                        text-align: center;
                        margin-top: 30px;
                        padding-top: 10px;
                        border-top: 1px solid #eee;
                        font-size: 12px;
                        color: #666;
                    }
                    
                    /* Responsive design */
                    @media (max-width: 768px) {
                        .report-metadata {
                            flex-direction: column;
                            gap: 10px;
                        }
                        .data-table {
                            font-size: 12px;
                        }
                        .data-table th, 
                        .data-table td {
                            padding: 6px;
                        }
                        
                        /* Enable horizontal scrolling for tables on small screens */
                        .table-container {
                            width: 100%;
                            overflow-x: auto;
                        }
                    }
                </style>
            </head>
            <body>
                <div class="report-header">
                    <h1>{{ report_title }}</h1>
                    <div class="report-metadata">
                        <div class="metadata-item">
                            <h3>{{ metadata_labels.report_type }}:</h3>
                            <p>{{ report_type }}</p>
                        </div>
                        <div class="metadata-item">
                            <h3>{{ metadata_labels.date_range }}:</h3>
                            <p>{{ date_range }}</p>
                        </div>
                        <div class="metadata-item">
                            <h3>{{ metadata_labels.generated_on }}:</h3>
                            <p>{{ generated_date }}</p>
                        </div>
                        <div class="metadata-item">
                            <h3>{{ metadata_labels.total_records }}:</h3>
                            <p>{{ record_count }}</p>
                        </div>
                    </div>
                </div>
                  <div class="table-container">
                    {{ table_html|safe }}
                </div>
                
                <div class="footer">
                    <p>{{ footer }} {{ generated_date }}</p>
                </div>
            </body>
            </html>
            """
              # Generate table HTML with better styling
            table_html = df.to_html(classes="data-table", index=False, border=1, escape=False)
            
            # Fix styling issue with table attributes
            table_html = table_html.replace('<table border="1" class="dataframe data-table">', 
                                          '<table class="data-table" cellspacing="0" cellpadding="5">')
            
            # Debug: Check if table_html contains escaped content
            print(f"DEBUG: First 200 chars of table_html: {table_html[:200]}")
            if "&lt;" in table_html or "&#34;" in table_html:
                print("WARNING: table_html already contains escaped HTML!")
              # Get report type from translations
            report_type_display = translations['report_types'].get(
                self.report_type, 
                self.report_type.capitalize()
            )
            
            # Prepare context for rendering
            date_range_text = self._format_date_range()
            generated_date = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            # Render HTML template
            html_content = render_template_string(
                html_template,
                language=lang,
                report_title=report_type_display,
                report_type=report_type_display,
                date_range=date_range_text,
                generated_date=generated_date,
                record_count=len(data),
                table_html=table_html,
                metadata_labels=translations['metadata_labels'],
                footer=translations['footer']
            )
            
            # Write HTML to file
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(html_content)
            
            # Store report metadata
            report_id = str(uuid.uuid4())
            _save_report_metadata(report_id, filename, len(data), lang)
            
            return {
                'success': True,
                'report_id': report_id,
                'filename': filename,
                'path': filename,
                'record_count': len(data)
            }
        except Exception as e:
            print(f"Error generating HTML report: {str(e)}")
            traceback.print_exc()
            return {'success': False, 'error': f'Failed to generate HTML report: {str(e)}'}

    def _generate_pdf(self, data):
        """Generate PDF report using available PDF backend."""
        if not data:
            return {'success': False, 'error': 'No data available for the report'}
        
        if not WEASYPRINT_AVAILABLE and not PDFKIT_AVAILABLE:
            return {'success': False, 'error': 'No PDF generation backend available. Please run install_pdf_deps.py to install necessary dependencies.'}
        
        try:
            # Use the language-specific translations
            lang = self.language if self.language in self.TRANSLATIONS else 'en'
            translations = self.TRANSLATIONS[lang]
              # Convert data to DataFrame
            df = pd.DataFrame(data)
            
            # Translate column headers and resize data for better display in PDF
            df = self._translate_dataframe_columns(df)
            df = self._translate_dataframe_values(df)  # Translate data values (for Polish)
            df = self._resize_table_for_pdf(df)
            
            # Generate filenames
            timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
            html_filename = f"{self.report_type}_report_{timestamp}.html"
            pdf_filename = f"{self.report_type}_report_{timestamp}.pdf"
            html_path = os.path.join(REPORTS_DIR, html_filename)
            pdf_path = os.path.join(REPORTS_DIR, pdf_filename)
            
            # Get report type from translations
            report_type_display = translations['report_types'].get(
                self.report_type, 
                self.report_type.capitalize()
            )
            
            # Create HTML template directly (don't rely on previous HTML generation)
            html_template = """
            <!DOCTYPE html>
            <html lang="{{ language }}">
            <head>
                <meta charset="UTF-8">
                <title>{{ report_title }}</title>
                <style>
                    body {
                        font-family: Arial, sans-serif;
                        line-height: 1.6;
                        margin: 20px;
                        color: #333;
                    }
                    h1 {
                        color: #2c3e50;
                        border-bottom: 2px solid #3498db;
                        padding-bottom: 10px;
                        margin-bottom: 20px;
                    }
                    .report-header {
                        background-color: #f8f9fa;
                        padding: 15px;
                        border-radius: 5px;
                        margin-bottom: 20px;
                    }
                    .report-metadata {
                        display: flex;
                        flex-wrap: wrap;
                        gap: 20px;
                        margin-bottom: 15px;
                    }
                    .metadata-item {
                        flex: 1 0 200px;
                    }
                    .metadata-item h3 {
                        margin: 0 0 5px 0;
                        font-size: 14px;
                        color: #666;
                    }
                    .metadata-item p {
                        margin: 0;
                        font-weight: bold;
                        color: #333;
                    }
                    table.data-table {
                        width: 100%;
                        border-collapse: collapse;
                        margin: 20px 0;
                        font-size: 12px; /* Smaller font size for PDF */
                    }
                    .data-table th, 
                    .data-table td {
                        padding: 6px;
                        border: 1px solid #ddd;
                        text-align: left;
                        word-wrap: break-word;
                        max-width: 200px; /* Limit column width */
                    }
                    .data-table th {
                        background-color: #f2f2f2;
                        color: #333;
                        font-weight: bold;
                    }
                    .data-table tr:nth-child(even) {
                        background-color: #f9f9f9;
                    }
                    .footer {
                        text-align: center;
                        margin-top: 30px;
                        padding-top: 10px;
                        border-top: 1px solid #eee;
                        font-size: 12px;
                        color: #666;
                    }
                    @page {
                        size: landscape; /* Use landscape orientation for wide tables */
                        margin: 2cm;
                    }
                </style>
            </head>
            <body>
                <div class="report-header">
                    <h1>{{ report_title }}</h1>
                    <div class="report-metadata">
                        <div class="metadata-item">
                            <h3>{{ metadata_labels.report_type }}:</h3>
                            <p>{{ report_type_display }}</p>
                        </div>
                        <div class="metadata-item">
                            <h3>{{ metadata_labels.date_range }}:</h3>
                            <p>{{ date_range }}</p>
                        </div>
                        <div class="metadata-item">
                            <h3>{{ metadata_labels.generated_on }}:</h3>
                            <p>{{ generated_date }}</p>
                        </div>
                        <div class="metadata-item">
                            <h3>{{ metadata_labels.total_records }}:</h3>
                            <p>{{ record_count }}</p>
                        </div>
                    </div>
                </div>
                
                <div class="table-container">
                    {{ table_html|safe }}
                </div>
                
                <div class="footer">
                    <p>{{ footer }} {{ generated_date }}</p>
                </div>
            </body>
            </html>
            """
            
            # Fix table HTML to ensure proper rendering in PDF
            # Generate table HTML with better styling for PDF
            table_html = df.to_html(classes="data-table", index=False)
              # Ensure there are no malformed tags or attributes in table
            table_html = table_html.replace('<table border="1" class="dataframe data-table">', 
                                          '<table class="data-table">')
            
            # Prepare context for rendering
            date_range_text = self._format_date_range()
            generated_date = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            # Render HTML template
            html_content = render_template_string(
                html_template,
                language=lang,
                report_title=report_type_display,
                report_type_display=report_type_display,
                date_range=date_range_text,
                generated_date=generated_date,
                record_count=len(data),
                table_html=table_html,
                metadata_labels=translations['metadata_labels'],
                footer=translations['footer']
            )
            
            # Write HTML to file
            with open(html_path, 'w', encoding='utf-8') as f:
                f.write(html_content)
            
            print(f"HTML file created: {html_path}")
            
            # Convert HTML to PDF using available backend
            if WEASYPRINT_AVAILABLE:
                try:
                    # Use HTML string directly rather than file to avoid encoding issues
                    HTML(string=html_content, base_url=REPORTS_DIR).write_pdf(pdf_path)
                    print(f"PDF generated successfully using WeasyPrint: {pdf_path}")
                except Exception as weasy_error:
                    print(f"WeasyPrint error: {str(weasy_error)}")
                    if PDFKIT_AVAILABLE:
                        print("Falling back to PDFKit")
                        pdfkit.from_string(html_content, pdf_path)
                    else:
                        raise weasy_error
            elif PDFKIT_AVAILABLE:
                try:
                    # Use string-based conversion rather than file-based
                    pdfkit.from_string(html_content, pdf_path)
                    print(f"PDF generated successfully using PDFKit: {pdf_path}")
                except Exception as pdfkit_error:
                    print(f"PDFKit error: {str(pdfkit_error)}")
                    raise pdfkit_error
            else:
                # This should not happen due to the check at the top, but just in case
                return {'success': False, 'error': 'No PDF generation backend available'}
            
            # Store report metadata
            report_id = str(uuid.uuid4())
            _save_report_metadata(report_id, pdf_filename, len(data), lang)
            
            return {
                'success': True,
                'report_id': report_id,
                'filename': pdf_filename,
                'path': pdf_filename,
                'record_count': len(data)
            }
        except Exception as e:
            print(f"Error generating PDF report: {str(e)}")
            traceback.print_exc()
            
            # Get error message in the right language
            lang = self.language if self.language in self.TRANSLATIONS else 'en'
            error_messages = {
                'en': {
                    'pdf_generation_failed': 'PDF generation failed. Please use Excel or HTML format.',
                    'run_install': 'To enable PDF generation, please run:',
                    'error': 'Error'
                },
                'pl': {
                    'pdf_generation_failed': 'Generowanie PDF nie powiodło się. Proszę użyć formatu Excel lub HTML.',
                    'run_install': 'Aby włączyć generowanie PDF, uruchom:',
                    'error': 'Błąd'
                }
            }[lang]
            
            # Create a fallback simple text file with installation instructions
            timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"{self.report_type}_report_{timestamp}.txt"
            filepath = os.path.join(REPORTS_DIR, filename)
            
            with open(filepath, 'w', encoding='utf-8') as f:
                report_title = self.TRANSLATIONS[lang]['report_types'].get(
                    self.report_type, 
                    self.report_type.capitalize()
                )
                f.write(f"{self.TRANSLATIONS[lang]['metadata_labels']['report_type']}: {report_title}\n")
                f.write(f"{self.TRANSLATIONS[lang]['metadata_labels']['generated_on']}: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                f.write(f"{self.TRANSLATIONS[lang]['metadata_labels']['total_records']}: {len(data)}\n\n")
                f.write(f"{error_messages['pdf_generation_failed']}\n\n")
                f.write(f"{error_messages['run_install']}\n")
                f.write("python install_pdf_deps.py\n\n")
                f.write(f"{error_messages['error']}: {str(e)}")
            
            # Store report metadata
            report_id = str(uuid.uuid4())
            _save_report_metadata(report_id, filename, len(data), lang)
            
            return {
                'success': False,
                'error': 'PDF generation failed. Please run install_pdf_deps.py to install necessary dependencies.',
                'report_id': report_id,
                'filename': filename,
                'path': filename
            }
    
    def _generate_excel(self, data):
        """Generate Excel report."""
        if not data:
            return {'success': False, 'error': 'No data available for the report'}
        
        try:
            # Use the language-specific translations
            lang = self.language if self.language in self.TRANSLATIONS else 'en'
            translations = self.TRANSLATIONS[lang]
              # Create a DataFrame from the data
            df = pd.DataFrame(data)
            
            # Translate column headers for the selected language
            df = self._translate_dataframe_columns(df)
            df = self._translate_dataframe_values(df)  # Translate data values (for Polish)
            
            # Generate filename
            timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"{self.report_type}_report_{timestamp}.xlsx"
            filepath = os.path.join(REPORTS_DIR, filename)
            
            # Get report type from translations
            report_type_display = translations['report_types'].get(
                self.report_type, 
                self.report_type.capitalize()
            )
            
            # Create Excel writer
            with pd.ExcelWriter(filepath, engine='openpyxl') as writer:
                df.to_excel(writer, index=False, sheet_name=report_type_display[:31])  # Excel sheet name limit is 31 characters
                
                # Auto-adjust column widths
                for column in df:
                    column_width = max(df[column].astype(str).map(len).max(), len(column)) + 2
                    # Limit too wide columns
                    column_width = min(column_width, 50)
                    col_idx = df.columns.get_loc(column) + 1
                    writer.sheets[report_type_display[:31]].column_dimensions[chr(64 + col_idx)].width = column_width
            
            # Store report metadata
            report_id = str(uuid.uuid4())
            _save_report_metadata(report_id, filename, len(data), lang)
            
            return {
                'success': True,
                'report_id': report_id,
                'filename': filename,
                'path': filename,
                'record_count': len(data)
            }
        except Exception as e:
            print(f"Error generating Excel report: {str(e)}")
            traceback.print_exc()
            return {'success': False, 'error': f'Failed to generate Excel report: {str(e)}'}
            
    def _generate_csv(self, data):
        """Generate CSV report."""
        if not data:
            return {'success': False, 'error': 'No data available for the report'}
        
        try:
            # Use the language-specific translations
            lang = self.language if self.language in self.TRANSLATIONS else 'en'
              # Convert data to DataFrame
            df = pd.DataFrame(data)
            
            # Translate column headers for the selected language
            df = self._translate_dataframe_columns(df)
            df = self._translate_dataframe_values(df)  # Translate data values (for Polish)
            
            # Generate filename
            timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"{self.report_type}_report_{timestamp}.csv"
            filepath = os.path.join(REPORTS_DIR, filename)
            
            # Write CSV file
            df.to_csv(filepath, index=False)
            
            # Store report metadata with language
            report_id = str(uuid.uuid4())
            _save_report_metadata(report_id, filename, len(data), lang)
            
            return {
                'success': True,
                'report_id': report_id,
                'filename': filename,
                'path': filename,
                'record_count': len(data)
            }
        except Exception as e:
            print(f"Error generating CSV report: {str(e)}")
            traceback.print_exc()
            return {'success': False, 'error': f'Failed to generate CSV report: {str(e)}'}

# Functions for getting and managing reports
def _save_report_metadata(report_id, filename, record_count, language=None):
    """Save report metadata to database with improved error handling."""
    try:
        with get_db_cursor() as cursor:
            # First, check if reports table exists; if not, create it
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS reports (
                    id VARCHAR(36) PRIMARY KEY,
                    name VARCHAR(255) NOT NULL,
                    type VARCHAR(50) NOT NULL,
                    format VARCHAR(10) NOT NULL,
                    record_count INT NOT NULL,
                    generated_by VARCHAR(50) NOT NULL,
                    generated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    path VARCHAR(255) NOT NULL,
                    report_params JSON DEFAULT NULL,
                    language VARCHAR(10) DEFAULT 'en'
                )
            """)
            
            # Check if language column exists, if not add it
            try:
                cursor.execute("""
                    SELECT * FROM INFORMATION_SCHEMA.COLUMNS 
                    WHERE TABLE_SCHEMA = DATABASE() 
                    AND TABLE_NAME = 'reports'
                    AND COLUMN_NAME = 'language'
                """)
                
                language_exists = cursor.fetchone() is not None
                
                if not language_exists:
                    print("Adding language column to reports table...")
                    cursor.execute("""
                        ALTER TABLE reports 
                        ADD COLUMN language VARCHAR(10) DEFAULT 'en'
                    """)
                    print("Language column added successfully")
            except Exception as col_error:
                print(f"Error checking/adding language column: {str(col_error)}")
                language_exists = False
            
            # Get report type and format from filename
            report_parts = filename.split('_')
            report_type = report_parts[0] if report_parts else 'unknown'
            report_format = filename.split('.')[-1] if '.' in filename else 'unknown'
            
            # Use the language or default to 'en'
            lang = language or 'en'
            
            # Save report metadata
            if language_exists:
                cursor.execute("""
                    INSERT INTO reports 
                    (id, name, type, format, record_count, generated_by, path, language)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
                """, (
                    report_id, 
                    filename, 
                    report_type, 
                    report_format,
                    record_count,
                    session.get('username', 'system'),
                    filename,  # Store just the filename, not full path
                    lang
                ))
            else:
                # Fall back to inserting without the language column
                cursor.execute("""
                    INSERT INTO reports 
                    (id, name, type, format, record_count, generated_by, path)
                    VALUES (%s, %s, %s, %s, %s, %s, %s)
                """, (
                    report_id, 
                    filename, 
                    report_type,
                    report_format,
                    record_count,
                    session.get('username', 'system'),
                    filename  # Store just the filename, not full path
                ))
    except Exception as e:
        print(f"Error saving report metadata: {str(e)}")
        traceback.print_exc()

def get_recent_reports(limit=10):
    """Get list of recently generated reports."""
    try:
        with get_db_cursor() as cursor:
            # First check if table exists
            cursor.execute("""
                SELECT EXISTS (
                    SELECT 1 
                    FROM information_schema.tables 
                    WHERE table_schema = DATABASE() 
                    AND table_name = 'reports'
                ) as table_exists
            """)
            
            result = cursor.fetchone()
            if not result or not result.get('table_exists'):
                return []
            
            # Get recent reports
            cursor.execute("""
                SELECT 
                    id, name, type, format, record_count, 
                    generated_by, generated_at, path, language
                FROM reports
                ORDER BY generated_at DESC
                LIMIT %s
            """, (limit,))
            
            return cursor.fetchall()
    except Exception as e:
        print(f"Error getting recent reports: {str(e)}")
        traceback.print_exc()
        return []

def get_report_by_id(report_id):
    """Get report details by ID."""
    try:
        with get_db_cursor() as cursor:
            cursor.execute("""
                SELECT 
                    id, name, type, format, record_count, 
                    generated_by, generated_at, path, language
                FROM reports
                WHERE id = %s
            """, (report_id,))
            
            return cursor.fetchone()
    except Exception as e:
        print(f"Error getting report by ID: {str(e)}")
        traceback.print_exc()
        return None

def delete_report(report_id):
    """Delete a report by ID."""
    try:
        # Get report info first
        report = get_report_by_id(report_id)
        if not report:
            return False
        
        # Delete file
        filepath = os.path.join(REPORTS_DIR, report['path'])
        if os.path.exists(filepath):
            os.remove(filepath)
        
        # Delete from database
        with get_db_cursor() as cursor:
            cursor.execute("DELETE FROM reports WHERE id = %s", (report_id,))
        
        return True
    except Exception as e:
        print(f"Error deleting report: {str(e)}")
        traceback.print_exc()
        return False
